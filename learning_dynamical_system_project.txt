Tasks that everyone has to do:
-read the two papers and write down questions to discuss (any question is very important)
-understand the relation between c_t (value of ambiguity set) and K_t (kalman gain)

Sasa obradovic:
-translation of Zorzi's code

Tommaso tubaldo:
-understand kalmannet code and see what can be reused for our purpose


Riccardo Zattra:
-understand kalmannet code and see what can be reused for our purpose


Question to be answered:
3) Relation between the C_t and K_t kalman gain (For me (ricky) I think that algorithm 1 at pag.3 of Zorzi's paper present the relation that we are looking for)
4) line 54 file parameters.py of folder lorenz attractor what is " ### Auxiliar MultiDimensional Tensor B and C (they make A --> Differential equation matrix)"?
5) check line 114 file main_lor_DT.py what the variable sys_model_pass2 does?
6) Which are the features relevant for the training of the DNN module? (starting from the 4 adopted in KNet, see pag.5 sec. B)
   Since in practice the state of the system is not always available, can we avoid using it as feature as suggested by Zorzi?
7) Which structure do we adopt for the DNN? Do we need a recursive formulation?
   Possible architectures: -the first architecture of KNet, i.e. an RNN with one or multiple GRU stages (see Fig.3 of the paper). In such
                             a way we exploit the recursive formulation of the Kalman Gain.
                           -a Feedforward NN from scratch
8) How do we choose c_t for REKF? Since in the paper it was defined as a decreasing exponential, i.e. c_t = c_0*exp(-0.0001t).
9) In the slide's of the presentation pag.3 there is the scheme of the robust EKF that is presented in Zorzi's article. Looking at
	algorithm one I'm not able to fully recognize the scheme, is someone able to highlight it?


Possible Errors on Sasa'code:
1) In file Robust Kalman.py -> line 21 it is written self.T = SysModel.T_test # The number of samples in the test data
	but according to the meaning of the variables args.T,args.T_test (in file main.ERKF.py -> line 36-37) I think
	that the correct line of code should be self.T = SysModel.T (I corrected it check it)
2) In file Robust Kalman.py -> line 58 there was written "h_jac = torch.autograd.functional.jacobian(self.model.f,x_rekf_temp)"
	I corrected it with "h_jac = torch.autograd.functional.jacobian(self.model.h,x_rekf_temp)" because that is the function
	to linearize h() (check it)

3)  In file Robust Kalman.py -> line 105 there was written P = self.A[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.A[:, :, i], 0, 1) - self.A[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.C[:, :, i], 0, 1) @ torch.Tensor.inverse(self.C[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.C[:, :, i], 0, 1)) @ self.C[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.A[:, :, i], 0, 1) + self.Q
	 I corrected it with P = self.A[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.A[:, :, i], 0, 1) - self.A[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.C[:, :, i], 0, 1) @ torch.Tensor.inverse(self.C[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.C[:, :, i], 0, 1) + self.R) @ self.C[:, :, i] @ self.V[:, :, i] @ torch.transpose(self.A[:, :, i], 0, 1) + self.Q
	(the correction is self.R inside the inverse which is the term D*transpose(D) in line 7 of algorithm 1 in Zorzi's article)
4) In file Robust Kalman.py -> line 99 what is G_t in the paper?

